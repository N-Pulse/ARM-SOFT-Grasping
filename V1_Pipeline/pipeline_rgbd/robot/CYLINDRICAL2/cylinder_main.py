import os
import sys
import re
import subprocess
import argparse
import cv2
import numpy as np
import pyrealsense2 as rs

# ─── Config ────────────────────────────────────────────────────────────────
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

# ─── Argument for the .ply file ────────────────────────────────────────────
parser = argparse.ArgumentParser(description="Cylinder grasp pipeline")
parser.add_argument(
    "ply",
    help="Path to the point-cloud (.ply) file generated by the pipeline",
)
args = parser.parse_args()

# ─── Helpers ──────────────────────────────────────────────────────────────

def extract_cylinder_dimensions(ply_path):
    """Extracts cylinder dimensions using fitting.py"""
    try:
        result = subprocess.run(
            [sys.executable, os.path.join(SCRIPT_DIR, "fitting.py"), ply_path],
            capture_output=True, text=True, check=True, cwd=SCRIPT_DIR
        )
        
        # Parse dimensions from output
        lines = result.stdout.split('\n')
        radius = None
        height = None
        diameter = None
        
        for line in lines:
            if "Radius (r):" in line:
                radius = float(line.split(':')[1].strip())
            elif "Height (h):" in line:
                height = float(line.split(':')[1].strip())
            elif "Diameter:" in line:
                diameter = float(line.split(':')[1].strip())
        
        return radius, height, diameter
    except subprocess.CalledProcessError as e:
        print(f"[ERR] fitting.py failed: {e.stderr}", file=sys.stderr)
        return None, None, None

def detect_approach_method():
    """Detects the approach method (top/body) with ArUco"""
    return "body"

# ─── Main ─────────────────────────────────────────────────────────────────

def main():
    print(f"[CYLINDER] Processing file: {args.ply}")
    
    # 1) Extract cylinder dimensions
    print("[CYLINDER] Extracting cylinder dimensions...")
    radius, height, diameter = extract_cylinder_dimensions(args.ply)
    
    if radius is None:
        print("[ERR] Unable to extract cylinder dimensions", file=sys.stderr)
        sys.exit(1)
    
    print(f"[CYLINDER] Extracted dimensions: radius={radius:.4f}m, height={height:.4f}m, diameter={diameter:.4f}m")
    
    # 2) Detect approach method
    approach = detect_approach_method()
    print(f"[CYLINDER] Detected approach method: {approach}")
    
    # 3) Processing according to approach
    if approach == "top":
        print("[CYLINDER] 'top' approach - extracting top...")
        try:
            subprocess.run(
                [sys.executable, os.path.join(SCRIPT_DIR, "extract_top.py"), args.ply],
                cwd=SCRIPT_DIR, check=True
            )
            # Use diameter for top grasp
            distance = diameter
        except subprocess.CalledProcessError as e:
            print(f"[ERR] extract_top.py failed: {e}", file=sys.stderr)
            sys.exit(1)
    else:  # body
        print("[CYLINDER] 'body' approach - extracting body...")
        try:
            subprocess.run(
                [sys.executable, os.path.join(SCRIPT_DIR, "extract_body.py"), args.ply],
                cwd=SCRIPT_DIR, check=True
            )
            # Use diameter for body grasp
            distance = diameter
        except subprocess.CalledProcessError as e:
            print(f"[ERR] extract_body.py failed: {e}", file=sys.stderr)
            sys.exit(1)
    
    # 4) Perform the grasp
    try:
        print(f"[CYLINDER] Executing grasp with distance={distance:.4f}m, approach={approach}...")
        grasp_cmd = [
            sys.executable, 
            os.path.join(SCRIPT_DIR, "cylinder_grasp.py"), 
            "--distance", f"{distance:.4f}",
            "--grasp", approach
        ]
        
        result = subprocess.run(grasp_cmd, capture_output=True, text=True, check=True)
        
        if result.stdout.strip():
            print(f"[CYLINDER] {result.stdout.strip()}")
        
        print("[CYLINDER] ✅ Grasp sequence completed successfully")
        
    except subprocess.CalledProcessError as e:
        print(f"[ERR] Grasp failed: {e.stderr}", file=sys.stderr)
        sys.exit(1)

    # 5) Wait for 'r' key to reset the arm
    print("Press 'r' then Enter to reset the arm, or any other key to exit.")
    choix = input("Your choice: ").strip().lower()
    if choix == 'r':
        reset_path = os.path.join(SCRIPT_DIR, os.pardir, "reset.py")
        if not os.path.exists(reset_path):
            print(f"[ERR] The file '{reset_path}' does not exist.", file=sys.stderr)
            sys.exit(1)
        print(f"[CYLINDER] Launching {reset_path} …")
        ret2 = subprocess.run([sys.executable, reset_path], check=False)
        if ret2.returncode != 0:
            print(f"[ERR] reset.py exited with code {ret2.returncode}", file=sys.stderr)
            sys.exit(ret2.returncode)
    else:
        print("[CYLINDER] Program finished.")

if __name__ == "__main__":
    main()